| Лабораторная работа №2     |  Б05                    | Архитектура компьютера |
| -------------------------- | ------------------------| ---------------------- |
| Построение логических схем | Габитов Булат Радикович | 2024                   |



## Инструментарий
Icarus Verilog version 12.0
Logisim-evolution 3.9.0

## Вариант
structural verilog normal
behaviour verilog normal
logisim normal

# Описание


# Отчет по модулям Verilog

## 1. Модуль `rs_trigger`

### Описание
Модуль `rs_trigger` реализует RS-триггер, который имеет два входа: `r` (reset) и `s` (set). Он генерирует два выхода: `q` и `neg_q`, где `q` — это текущее состояние триггера, а `neg_q` — его инверсное состояние.

### Работа
- Если `s` активен (1), то `q` устанавливается в 1.
- Если `r` активен (1), то `q` сбрасывается в 0.
- Если оба входа неактивны, состояние триггера сохраняется.

### Тесты поведения
- **Тест 1**: При `s = 1`, `r = 0`, ожидается, что `q = 1`, `neg_q = 0`.
- **Тест 2**: При `s = 0`, `r = 1`, ожидается, что `q = 0`, `neg_q = 1`.
- **Тест 3**: При `s = 0`, `r = 0`, ожидается, что состояние сохраняется (предыдущее значение).

---

## 2. Модуль `sync_rs_trigger`

### Описание
Модуль `sync_rs_trigger` представляет собой синхронизированный RS-триггер. Он принимает входы `r`, `s` и синхронизирующий сигнал `sync`. Входы `r` и `s` обрабатываются с учетом сигнала синхронизации.

### Работа
- Входы `new_r` и `new_s` создаются путем логического И между входами и сигналом синхронизации.
- Затем эти сигналы передаются в модуль RS-триггера для генерации выходов.

### Тесты поведения
- **Тест 1**: При `r = 1`, `s = 0`, и активном сигнале синхронизации (`sync = 1`), ожидается, что триггер будет установлен (`q = 1`).
- **Тест 2**: При `r = 0`, `s = 1`, и активном сигнале синхронизации (`sync = 1`), ожидается, что триггер будет сброшен (`q = 0`).
- **Тест 3**: Проверка на отсутствие изменений при неактивном сигнале синхронизации.

---

## 3. Модуль `d_trigger`

### Описание
Модуль `d_trigger` реализует D-триггер. Он принимает на вход данные (`d`) и синхронизирующий сигнал (`sync`). Выходной сигнал (`q`) устанавливается в состояние входа данных на фронте сигнала синхронизации.

### Работа
- Инвертированное значение входа данных (`not_d`) передается в синхронизированный RS-триггер вместе с оригинальным значением данных.
- На фронте сигнала синхронизации значение данных сохраняется на выходе.

### Тесты поведения
- **Тест 1**: При входе данных (`d = 1`) и активном сигнале синхронизации (`sync = 1`), ожидается, что выход (`q`) станет равным 1.
- **Тест 2**: При входе данных (`d = 0`) и активном сигнале синхронизации, ожидается, что выход станет равным 0.
- **Тест 3**: Проверка на отсутствие изменений при неактивном сигнале синхронизации.

---

## 4. Модуль `d_2_bits_trigger`

### Описание
Модуль `d_2_bits_trigger` реализует два D-триггера для обработки двухбитного входа данных. Он принимает сигнал сброса (`reset`) и синхронизирующий сигнал (`sync`).

---

## 5. Модуль `d_4_bits_trigger`

### Описание
Модуль `d_4_bits_trigger` расширяет функциональность предыдущего модуля до четырех битов. Он также принимает сигнал сброса и синхронизирующий сигнал для управления четырьмя D-триггерами.

### Работа
- Логика аналогична модулю для двух битов, но теперь обрабатываются четыре бита данных.
- Каждый бит данных передается в отдельный D-триггер с учетом состояния сброса и сигнала синхронизации.
- При сбросе (`reset = 1`) все выходы обнуляются

---

## 6. Модуль `d_3_bits_trigger`

### Описание
Модуль `d_3_bits_trigger` реализует трехбитный D-триггер. Он принимает сигнал сброса (`reset`), синхронизирующий сигнал (`sync`) и трехбитный вход данных (`d`). Выходной сигнал (`q`) представляет собой состояние триггера.

### Работа
- Входные данные расширяются до 4 бит, добавляя старший ноль.
- Сигналы передаются в модуль `d_4_bits_trigger`, который управляет состоянием выходов на основе входных данных и синхронизации.
- Выходы `q` формируются из первых трех битов расширенного выхода.
- При `reset = 1`, ожидается, что все выходы `q` будут равны 0.

---

## 7. Модуль `dec_3_8`

### Описание
Модуль `dec_3_8` представляет собой декодер 3-8. Он принимает трехбитный вход (`a`) и активирует один из восьми выходов (`q`) в зависимости от значения входа.

### Работа
- Каждый выход активируется, если значение входа совпадает с его индексом. Например, если `a = 3'b010`, то `q[2]` будет равно 1, а остальные выходы будут равны 0.

### Тесты поведения
- **Тест 1**: При `a = 3'b000`, ожидается, что `q[0] = 1`, остальные выходы равны 0.
- **Тест 2**: При `a = 3'b111`, ожидается, что `q[7] = 1`, остальные выходы равны 0.

---

## 8. Модуль `half_adder`

### Описание
Модуль `half_adder` реализует полусумматор, который принимает два бита (`a` и `b`) и генерирует сумму (`sum`) и перенос (`carry`).

### Работа
- Сумма вычисляется с помощью операции XOR.
- Перенос вычисляется с помощью операции AND.

### Тесты поведения
- **Тест 1**: При входах `a = 0`, `b = 0`, ожидается, что `sum = 0`, `carry = 0`.
- **Тест 2**: При входах `a = 1`, `b = 0`, ожидается, что `sum = 1`, `carry = 0`.
- **Тест 3**: При входах `a = 1`, `b = 1`, ожидается, что `sum = 0`, `carry = 1`.

---

## 9. Модуль `full_adder`

### Описание
Модуль `full_adder` реализует полный сумматор, который принимает два бита (`a` и `b`) и перенос (`carry_in`). Он генерирует сумму (`sum`) и перенос выхода (`carry_out`).

### Работа
- Используются два полусумматора для вычисления суммы и переноса.
- Перенос выхода вычисляется как логическое И между промежуточными переносами.

### Тесты поведения
- **Тест 1**: При входах `a = 0`, `b = 0`, и `carry_in = 0`, ожидается, что сумма будет равна 0, а перенос выхода будет равен 0.
- **Тест 2**: При входах `a = 1`, `b = 1`, и `carry_in = 0`, ожидается, что сумма будет равна 0, а перенос выхода будет равен 1.

---

## 10. Модуль `three_bit_adder`

### Описание
Модуль `three_bit_adder` реализует трехбитный сумматор. Он принимает два трехбитных числа (`a` и `b`) и генерирует четырехбитный выход (`s`), который включает сумму и возможный перенос.

### Работа
- Используются три полных сумматора для обработки каждого бита входных данных.
- Перенос от одного сумматора передается на следующий.

### Тесты поведения
- **Тест 1**: При входах `a = 3'b000` и `b = 3'b000`, ожидается, что сумма будет равна `4'b0000`.
- **Тест 2**: При входах `a = 3'b101` и `b = 3'b011`, ожидается, что сумма будет равна `4'b1000`.

---

## 11. Модуль `four_bit_adder`

### Описание
Модуль `four_bit_adder` реализует четырехбитный сумматор. Он принимает два 4-битных числа (`a` и `b`) и генерирует 5-битный выход (`s`), который включает сумму и возможный перенос.

### Работа
- Модуль использует другой модуль `three_bit_adder` для сложения младших трех битов входных данных.
- Четвертый бит складывается с учетом переноса от предыдущего сумматора, используя модуль `full_adder`.
- Выходной сигнал `s` формируется из суммы младших трех битов и четвертого бита, включая перенос.

### Тесты поведения
- **Тест 1**: При входах `a = 4'b0000` и `b = 4'b0000`, ожидается, что сумма будет равна `5'b00000`.
- **Тест 2**: При входах `a = 4'b0101` и `b = 4'b0011`, ожидается, что сумма будет равна `5'b01000`.
- **Тест 3**: При входах `a = 4'b1111` и `b = 4'b0001`, ожидается, что сумма будет равна `5'b10000`.

---

## 12. Модуль `five_bit_adder`

### Описание
Модуль `five_bit_adder` реализует пятибитный сумматор. Он принимает два 5-битных числа (`a` и `b`) и генерирует 6-битный выход (`s`), который включает сумму и возможный перенос.

### Работа
- Модуль использует модуль `four_bit_adder` для сложения младших четырех битов входных данных.
- Пятый бит складывается с учетом переноса от предыдущего сумматора, используя модуль `full_adder`.
- Выходной сигнал `s` формируется из суммы младших четырех битов и пятого бита, включая перенос.

### Тесты поведения
- **Тест 1**: При входах `a = 5'b00000` и `b = 5'b00000`, ожидается, что сумма будет равна `6'b000000`.
- **Тест 2**: При входах `a = 5'b01010` и `b = 5'b00101`, ожидается, что сумма будет равна `6'b010000`.
- **Тест 3**: При входах `a = 5'b11111` и `b = 5'b00001`, ожидается, что сумма будет равна `6'b100000`.

---

## 13. Модуль `neg_5_bits`

### Описание
Модуль `neg_5_bits` вычисляет отрицательное значение для 5-битного числа. Он использует инвертирование входа и добавление единицы для получения отрицательного значения.

### Работа
- Входное значение инвертируется с помощью логических NOT.
- К инвертированному значению добавляется константа `1`, используя модуль `five_bit_adder`.
- Выходной сигнал (`q`) представляет собой результат операции.

### Тесты поведения
- **Тест 1**: При входе `a = 5'b00000`, ожидается, что выход будет равен `5'b00000`.
- **Тест 2**: При входе `a = 5'b00001`, ожидается, что выход будет равен `5'b11111`.
- **Тест 3**: При входе `a = 5'b11111`, ожидается, что выход будет равен `5'b00001`.

---

## 14. Модуль `is_more_5`

### Описание
Модуль `is_more_5` проверяет, больше или равно ли входное значение (`a`) числа 5. Он использует отрицательное значение числа 5 и суммирует его с входным значением.

### Работа
- Сначала вычисляется отрицательное значение числа 5 с помощью модуля `neg_5_bits`.
- Затем используется модуль `five_bit_adder`, чтобы сложить отрицательное значение с входным значением.
- Если старший бит результата (перенос) равен нулю, то это означает, что входное значение больше числа 5.

### Тесты поведения
- **Тест 1**: При входе `a = 5'b00110`, ожидается, что выход будет равен `1` (больше чем 5).
- **Тест 2**: При входе `a = 5'b00101`, ожидается, что выход будет равен `1` (равно 5).
- **Тест 3**: При входе `a = 5'b00001`, ожидается, что выход будет равен `0` (меньше 5).

---

## 15. Модуль `is_more_10`

### Описание
Модуль `is_more_10` проверяет, больше или равно ли входное значение (`a`) числа 10. Он использует аналогичный подход к модулю проверки на большее значение чем пять.

### Работа
- Сначала вычисляется отрицательное значение числа 10 с помощью модуля `neg_5_bits`.
- Затем используется модуль `five_bit_adder`, чтобы сложить отрицательное значение с входным значением.
- Если старший бит результата (перенос) равен нулю, то это означает, что входное значение больше числа 10.

### Тесты поведения
- **Тест 1**: При входе `a = 5'b01011`, ожидается, что выход будет равен `1` (больше чем 10).
- **Тест 2**: При входе `a = 5'b01010`, ожидается, что выход будет равен `1` (равно 10).
- **Тест 2**: При входе `a = 5'b00100`, ожидается, что выход будет равен `0` (меньше 10).
---


## 16. Модуль `mod5`

### Описание
Модуль `mod5` вычисляет остаток от 4-битного входного значения при делении на 5. Он использует отрицательные значения чисел 5 и 10 для проверки, попадает ли входное значение в определенные диапазоны.

### Работа
- Входное значение `a` расширяется до 5 бит.
- Вычисляется отрицательное значение для 5 и 10 с помощью модуля `neg_5_bits`.
- Проверяется, больше ли входное значение 10.
- Если входное значение больше 10, то к нему добавляется отрицательное значение 10.
- Затем проверяется, больше ли результат 5, и если да, то результат сохраняется.

### Тесты поведения
- **Тест 1**: При входе `a = 4'b00000`, ожидается, что выход будет равен `3'b000`.
- **Тест 2**: При входе `a = 4'b01010`, ожидается, что выход будет равен `3'b000`.
- **Тест 3**: При входе `a = 4'b00111`, ожидается, что выход будет равен `3'b010`.

---

## 17. Модуль `next_index`

### Описание
Модуль `next_index` вычисляет следующий индекс на основе команды (`cmd`), синхронизирующего сигнала (`sync`) и текущего индекса (`index`). Он использует модуль `mod5` для вычисления нового индекса.

### Работа
- Сигналы команды обрабатываются для определения, какие операции выполнять (инкремент или сброс).
- Сигналы обрабатываются с учетом синхронизации.
- Результат передается в модуль `mod5`, который вычисляет новый индекс.

---

## 18. Модуль `current_index`

### Описание
Модуль `current_index` управляет текущим индексом на основе сигналов сброса (`reset`), команд (`cmd`) и синхронизации (`sync`). Он использует два триггера D для хранения значения индекса.

### Работа
- Использует инверсный сигнал синхронизации для управления состоянием триггеров.
- Сигнал сброса сбрасывает текущее состояние индекса.
- Следующий индекс вычисляется с помощью модуля `next_index`.


---


## 19. Модуль `memory`

### Описание
Модуль `memory` реализует память с возможностью записи и чтения данных. Он принимает команды, индекс, данные и синхронизирующий сигнал, а также генерирует выходные данные для нескольких регистров.

### Работа
- Входные данные обрабатываются в зависимости от команд (`cmd`), которые определяют, будет ли происходить запись или чтение.
- Индекс используется для выбора конкретного регистра памяти.
- Сигнал синхронизации управляет тем, когда данные должны быть записаны или считаны.

### Тесты поведения

---

## 20. Модуль `neg_4_bits`

### Описание
Модуль `neg_4_bits` вычисляет отрицательное значение для 4-битного числа. Он использует инвертирование входа и добавление единицы для получения отрицательного значения.

### Работа
- Входное значение инвертируется с помощью логических NOT.
- К инвертированному значению добавляется константа `1`, используя модуль `four_bit_adder`.
- Выходной сигнал (`q`) представляет собой результат операции.

### Тесты поведения
- **Тест 1**: При входе `a = 4'b0000`, ожидается, что выход будет равен `4'b0001`.
- **Тест 2**: При входе `a = 4'b0001`, ожидается, что выход будет равен `4'b1111`.
- **Тест 3**: При входе `a = 4'b1111`, ожидается, что выход будет равен `4'b0001`.

---

## 21. Модуль `neg_mod_5`

### Описание
Модуль `neg_mod_5` вычисляет отрицательное значение для 3-битного числа и проверяет его по модулю 5.

### Работа
- Входное значение расширяется до 4 бит.
- Вычисляется отрицательное значение с помощью модуля `neg_4_bits`.
- Затем используется модуль `mod5`, чтобы получить остаток от деления на 5.

### Тесты поведения
- **Тест 1**: При входе `a = 3'b000`, ожидается, что выход будет равен `3'b000`.
- **Тест 2**: При входе `a = 3'b010`, ожидается, что выход будет равен `3'b011`.
- **Тест 3**: При входе `a = 3'b111`, ожидается, что выход будет равен `3'b011`.

---

## 22. Модуль `inout_cmd`

### Описание
Модуль `inout_cmd` управляет вводом и выводом данных на основе команд. Он использует NMOS и PMOS транзисторы для управления состоянием.

### Работа
- Входные команды обрабатываются для определения, какие данные должны быть записаны или считаны.
- Используются транзисторы для управления состоянием выходных данных в зависимости от команд.

### Тесты поведения


---

## 23. Модуль `shift_index`

### Описание
Модуль `shift_index` вычисляет новый индекс на основе команд и текущего индекса. Он использует модули для проверки значений и выполнения арифметических операций.

### Работа
- Входные команды обрабатываются для определения следующего индекса.
- Синхронизирующий сигнал управляет тем, когда изменения должны происходить.
- Индекс обновляется в зависимости от текущего состояния и команд.

### Тесты поведения


---

## 24. Модуль `stack_structural_normal`

### Описание
Модуль `stack_structural_normal` реализует стек с возможностью записи и чтения данных. Он управляет состоянием стека на основе сигналов сброса и синхронизации.

### Работа
- Использует триггеры D для хранения данных в стеке.
- Управляет состоянием стека в зависимости от команд и синхронизации.
- Обеспечивает ввод/вывод данных через интерфейс команд.

### Тесты поведения

